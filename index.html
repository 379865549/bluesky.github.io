<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>git使用</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><p></p><div class="toc"><h3>文章目录</h3><ul><li><a href="#window_1">window安装</a></li><li><a href="#Git__42">Git 的初始化</a></li><li><a href="#Git_64">获得一个Git仓库</a></li><ul><li><a href="#_86">初始化一个新的仓库</a></li></ul><li><a href="#_109">正常的工作流程</a></li><ul><li><a href="#_118">创建或修改文件</a></li><li><a href="#_git_add__150">使用 git add 加入缓存区</a></li><li><a href="#_git_commit__176">使用 git commit 提交修改</a></li></ul><li><a href="#_207">分支与合并</a></li><ul><li><a href="#_210">创建分支</a></li><li><a href="#_224">切换分支</a></li><li><a href="#_242">合并分支</a></li><li><a href="#_316">删除分支</a></li><li><a href="#_325">撤销一个合并</a></li><li><a href="#_334">快速向前合并</a></li></ul><li><a href="#Git__340">Git 日志</a></li><ul><li><a href="#_341">查看日志</a></li><li><a href="#_357">日志统计</a></li><li><a href="#_365">格式化日志</a></li><li><a href="#_384">日志排序</a></li></ul><li><a href="#_409">比较内容</a></li><ul><li><a href="#__Git_Diff_410">比较提交 - Git Diff</a></li><li><a href="#_492">比较分支</a></li><li><a href="#_530">更多的比较选项</a></li></ul><li><a href="#_575">分布式的工作流程</a></li><ul><li><a href="#_577">分布式的工作流程</a></li><li><a href="#_Git__704">公共 Git 仓库</a></li><li><a href="#_718">将修改推到一个公共仓库</a></li><li><a href="#_734">当推送代码失败时要怎么办</a></li></ul><li><a href="#Git_751">Git标签</a></li><ul><li><a href="#_752">轻量级标签</a></li><li><a href="#_790">签名的标签</a></li></ul></ul></div><p></p>
<h1><a id="window_1"></a>window安装</h1>
<p>第一步：双击下载后的Git-2.21.0-64-bit.exe，开始安装<br>
<img src="https://img-blog.csdnimg.cn/20200319001253871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">第二步：选择安装路径，点击[next]</p>
<p>第三步：在窗口中选择组件，添加勾选倒数第二个组件：在所有命令行中使用Truetype字体，点击[next]<br>
<img src="https://img-blog.csdnimg.cn/20200319002221331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200319002307113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
第四步：选择默认编辑器，我日常使用Vscode作为编辑器，勾选使用 Visual Studio Code 作为 Git 的默认编辑器，点击[next]<br>
<img src="https://img-blog.csdnimg.cn/20200319001409203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">第五步：[创建文件夹]界面，选项默认，点击[next]</p>
<p>第六步：[修改系统的环境变量]界面，我勾选的第二个选项，点击[next]</p>
<p><img src="https://img-blog.csdnimg.cn/20200319002341340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">设置环境变量</p>
<p>选择使用什么样的命令行工具，一般情况下我们默认使用Git Bash即可：</p>
<p>（1）Git自带：使用Git自带的Git Bash命令行工具。</p>
<p>（2）系统自带CMD：使用Windows系统的命令行工具。</p>
<p>（3）二者都有：上面二者同时配置，但是注意，这样会将windows中的find.exe 和 sort.exe工具覆盖，如果不懂这些尽量不要选择。</p>
<p>7、选择之后，继续点击“Next”，显示如下：<br>
<img src="https://img-blog.csdnimg.cn/20200319002704450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/202003190032562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">选择提交的时候换行格式</p>
<p>（1）检查出windows格式转换为unix格式：将windows格式的换行转为unix格式的换行再进行提交。</p>
<p>（2）检查出原来格式转为unix格式：不管什么格式的，一律转为unix格式的换行再进行提交。</p>
<p>（3）不进行格式转换 : 不进行转换，检查出什么，就提交什么。</p>
<p>8、选择之后，点击“Next”，显示截图如下：<br>
<img src="https://img-blog.csdnimg.cn/20200319003401710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
9、选择之后，点击“Next”，显示截图如下：<br>
<img src="https://img-blog.csdnimg.cn/20200319003425517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">10、选择之后，点击“Install”，开始安装，截图显示如下：<br>
<img src="https://img-blog.csdnimg.cn/20200319003611276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">12、安装完成后，还需要最后一步设置，在命令行输入如下：<br>
<img src="https://img-blog.csdnimg.cn/20200319003630766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQzOTI4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p>
<p>注意：<code>git config --global</code> 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p>
<p>这样，我们的Git客户端就下载并安装完成了。</p>
<h1><a id="Git__42"></a>Git 的初始化</h1>
<p>在使用 Git进行代码管理之前，我们首先要对 Git 进行初始化配置。</p>
<p>使用 Git 的第一件事就是设置你的名字和 email，这些就是你在提交 <code>commit</code> 时的签名，每次提交记录里都会包含这些信息。使用<code>git config</code> 命令进行配置：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"Scott Chacon"</span>
$ <span class="token function">git</span> config --global user.email <span class="token string">"schacon@gmail.com"</span>
</code></pre>
<p>执行了上面的命令后，会在家目录（<code>/home/shiyanlou</code>）下建立一个叫 .gitconfig 的文件（该文件为隐藏文件，需要使用<code>ls -al</code>查看到）. 内容一般像下面这样，可以使用<code>vim</code>或<code>cat</code>查看文件内容:</p>
<pre><code class="prism language-bash">$ <span class="token function">cat</span> ~/.gitconfig
<span class="token punctuation">[</span>user<span class="token punctuation">]</span>
        email <span class="token operator">=</span> schacon@gmail.com
        name <span class="token operator">=</span> Scott Chacon
</code></pre>
<p>上面的配置文件就是 Git 全局配置的文件，一般配置方法是 <code>git config --global &lt;配置名称&gt; &lt;配置的值&gt;</code>。</p>
<p>如果你想使项目里的某个值与前面的全局设置有区别（例如把私人邮箱地址改为工作邮箱），你可以在项目中使用 <code>git config</code> 命令不带<code>--globa</code>l 选项来设置. 这会在你当前的项目目录下创建<code>.git/config</code>，从而使用针对当前项目的配置。</p>
<h1><a id="Git_64"></a>获得一个Git仓库</h1>
<p>既然我们现在把一切都设置好了，那么我们需要一个 Git 仓库。有两种方法可以得到它：一种是从已有的Git 仓库中<code>clone</code> （克隆，复制）；还有一种是新建一个仓库，把未进行版本控制的文件进行版本控制<br>
Clone一个仓库</p>
<p>为了得到一个项目的拷贝（<code>copy</code>），我们需要知道这个项目仓库的地址（Git URL）。Git 能在许多协议下使用，所以 Git URL 可能以 <code>ssh://</code>，<code>http（s）://</code>，<code>git://</code>开头。有些仓库可以通过多种协议来访问。</p>
<p>我们在 <code>github.com</code> 上提供了一个名字为 <code>gitproject</code> 的供大家测试的公有仓库，这个仓库可以使用下面方式进行 <code>clone</code>：</p>
<pre><code class="prism language-bash">$ <span class="token function">cd</span> /home/shiyanlou/
$ <span class="token function">git</span> clone https://github.com/shiyanlou/gitproject
</code></pre>
<p><code>clone</code>操作完成后，会发现<code>/home/shiyanlou</code>目录下多了一个 <code>gitproject</code>文件夹，这个文件夹里的内容就是我们刚刚 <code>clone</code> 下来的代码。由于当前 <code>gitproject</code>仅是测试项目，里面仅有一个 README.md 文件。</p>
<pre><code class="prism language-bash">$ <span class="token function">cd</span> gitproject/
（master）$ <span class="token function">ls</span> 
README.md
</code></pre>
<p>命令提示符 $ 前面多了个 （<code>master</code>）。这是由于实验楼的 Linux 使用的是zsh Shell，zsh 会判断当前的目录是否有 Git 仓库，如果是的话则自动把目前所在的 Git 分支显示在提示符中。Git 分支的概念我们会在稍后介绍。</p>
<h2><a id="_86"></a>初始化一个新的仓库</h2>
<p>可以对一个已存在的文件夹用下面的命令让它置于 Git 的版本控制管理之下。</p>
<p>创建代码目录 <code>project</code>：</p>
<pre><code class="prism language-bash">$ <span class="token function">cd</span> /home/shiyanlou/
$ <span class="token function">mkdir</span> project
</code></pre>
<p>进入到代码目录，创建并初始化Git仓库：</p>
<pre><code class="prism language-bash">$ <span class="token function">cd</span> project
$ <span class="token function">git</span> init
</code></pre>
<p>Git 会输出:</p>
<pre><code class="prism language-bash">Initialized empty Git repository <span class="token keyword">in</span> /home/shiyanlou/project/.git/
</code></pre>
<p>通过<code>ls -la</code> 命令会发现project目录下会有一个名叫<code>.git</code> 的目录被创建，这意味着一个仓库被初始化了。可以进入到<code>.git</code>目录查看下有哪些内容。</p>
<h1><a id="_109"></a>正常的工作流程</h1>
<p>Git 的基本流程如下：</p>
<ul>
<li>创建或修改文件</li>
<li>使用 <code>git add</code> 命令添加新创建或修改的文件到本地的缓存区（Index）</li>
<li>使用 <code>git commit</code>命令提交到本地代码库</li>
<li>（可选，有的时候并没有可以同步的远端代码库）使用<code>git push</code>命令将本地代码库同步到远端代码库</li>
</ul>
<h2><a id="_118"></a>创建或修改文件</h2>
<p>进入我们刚才建立的 project 目录，分别创建文件 file1，file2，file3：</p>
<pre><code class="prism language-bash">$ <span class="token function">cd</span> /home/shiyanlou/project
$ <span class="token function">touch</span> file1 file2 file3
</code></pre>
<p>修改文件，可以使用 vim 编辑内容，也可以直接 echo 添加测试内容。</p>
<pre><code class="prism language-bash">$ <span class="token keyword">echo</span> <span class="token string">"test"</span> <span class="token operator">&gt;&gt;</span> file1
$ <span class="token keyword">echo</span> <span class="token string">"test"</span> <span class="token operator">&gt;&gt;</span> file2
$ <span class="token keyword">echo</span> <span class="token string">"test"</span> <span class="token operator">&gt;&gt;</span> file3
</code></pre>
<p>此时可以使用 <code>git status</code> 命令查看当前 Git 仓库的状态：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> status
On branch master

Initial commit

Untracked files:
   （use <span class="token string">"git add &lt;file&gt;..."</span>） to include <span class="token keyword">in</span> what will be committed）

       file1
       file2
       file3
nothing added to commit but untracked files present （use <span class="token string">"git add"</span> to track）
</code></pre>
<p>可以发现，有三个文件处于<code>untracked</code>状态，下一步我们就需要用 <code>git add</code>命令将他们加入到缓存区（Index）。</p>
<h2><a id="_git_add__150"></a>使用 git add 加入缓存区</h2>
<p>使用 git add 命令将新建的文件添加到缓存区：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> add file1 file2 file3
</code></pre>
<p>然后再次执行<code>git status</code> 就会发现新的变化：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> status
On branch master

Initial commit

Changes to be committed:
    （use <span class="token string">"git rm --cached &lt;file&gt;..."</span> to unstage）

       new file: file1
       new file: file2
       new file: file3
</code></pre>
<p>你现在为<code>commit</code> 做好了准备，你可以使用<code>git diff</code>命令再加上<code>--cached</code> 参数，看看缓存区中哪些文件被修改了。进入到<code>git diff --cached</code>界面后需要输入<code>q</code>才可以退出：<br>
如果没有<code>--cached</code>参数，<code>git diff</code>会显示当前你所有已做的但没有加入到缓存区里的修改。</p>
<p>如果你要做进一步的修改， 那就继续做， 做完后就把新修改的文件加入到缓存区中。</p>
<h2><a id="_git_commit__176"></a>使用 git commit 提交修改</h2>
<p>当所有新建，修改的文件都被添加到了缓存区，我们就要使用<code>git commit</code>提交到本地仓库：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"add 3 files"</span>
</code></pre>
<p>需要使用 <code>-m</code> 添加本次修改的注释，完成后就会记录一个新的项目版本。除了用 <code>git add</code> 命令，我们还可以用下面的<code>-a</code>参数将所有没有加到缓存区的修改也一起提交，但 <code>-a</code>命令不会添加新建的文件。</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> commit -a -m <span class="token string">"add 3 files"</span>
</code></pre>
<p>再次输入 <code>git status</code>查看状态，会发现当前的代码库已经没有待提交的文件了，缓存区已经被清空。</p>
<p>至此，我们完成了第一次代码提交，这次提交的代码中我们创建了三个新文件。需要注意的是如果是修改文件，也需要使用 <code>git add</code> 命令添加到缓存区才可以提交。如果是删除文件，则直接使用 <code>git rm</code> 命令删除后会自动将已删除文件的信息添加到缓存区，<code>git commit</code>提交后就会将本地仓库中的对应文件删除。</p>
<p>这时如果我们希望将本地仓库关联到远端服务器，我们可以使用 <code>git remote</code>命令，不同于刚刚的<code>git clone</code> 命令，直接将远端的仓库克隆下来。</p>
<p>我们当前的仓库是使用<code>git init</code> 初始化的本地仓库，所以我们需要将本地仓库与远程仓库关联，使用如下命令（需要修改下面的远程仓库地址为自己的仓库地址）：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> remote add origin https://github.com/kinglion580/shiyanlou.git
</code></pre>
<p>对于上述命令而言，<code>git remote add</code> 命令用于添加远程主机，<code>origin</code> 是主机名，此处我们可以自定义，不一定非要使用<code>origin</code>，而 <code>https://github.com/kinglion580/shiyanlou.git</code>，是我自己的远程仓库，此处 需要替换为自己的远程仓库地址</p>
<p>这个时候如果本地的仓库连接到了远程Git服务器，可以使用下面的命令将本地仓库同步到远端服务器：</p>
<pre><code class="prism language-bash"><span class="token comment"># 需要输入仓库对应的用户名和密码</span>
$ <span class="token function">git</span> push origin master
</code></pre>
<h1><a id="_207"></a>分支与合并</h1>
<p>Git 的分支可以让你在主线（master 分支）之外进行代码提交，同时又不会影响代码库主线。分支的作用体现在多人协作开发中，比如一个团队开发软件，你负责独立的一个功能需要一个月的时间来完成，你就可以创建一个分支，只把该功能的代码提交到这个分支，而其他同事仍然可以继续使用主线开发，你每天的提交不会对他们造成任何影响。当你完成功能后，测试通过再把你的功能分支合并到主线。</p>
<h2><a id="_210"></a>创建分支</h2>
<p>一个 Git 仓库可以维护很多开发分支。现在我们来创建一个新的叫 experimental 的分支：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> branch experimental
</code></pre>
<p>运行 git branch 命令可以查看当前的分支列表，以及目前的开发环境处在哪个分支上：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> branch
 experimental
* master
</code></pre>
<h2><a id="_224"></a>切换分支</h2>
<p>experimental 分支是你刚才创建的，master 分支是 Git 系统默认创建的主分支。星号标识了你当工作在哪个分支下，输入<code>git checkout</code>分支名 可以切换到其他分支：</p>
<pre><code class="prism language-bash"><span class="token comment"># 修改文件file1</span>
$ <span class="token keyword">echo</span> <span class="token string">"update"</span> <span class="token operator">&gt;&gt;</span> file1
<span class="token comment"># 查看当前状态</span>
$ <span class="token function">git</span> status
<span class="token comment"># 添加并提交file1的修改</span>
$ <span class="token function">git</span> add file1
$ <span class="token function">git</span> commit -m <span class="token string">"update file1"</span>
<span class="token comment"># 查看file1的内容</span>
$ <span class="token function">cat</span> file1
<span class="token function">test</span>
update
<span class="token comment"># 切换到master分支</span>
$ <span class="token function">git</span> checkout master
</code></pre>
<h2><a id="_242"></a>合并分支</h2>
<p>现在可以在 master 分支下再作一些不同的修改</p>
<pre><code class="prism language-bash"><span class="token comment"># 修改文件file2</span>
$ <span class="token keyword">echo</span> <span class="token string">"update again"</span> <span class="token operator">&gt;&gt;</span> file2
<span class="token comment"># 查看当前状态</span>
$ <span class="token function">git</span> status
<span class="token comment"># 添加并提交file2的修改</span>
$ <span class="token function">git</span> add file2
$ <span class="token function">git</span> commit -m <span class="token string">"update file2 on master"</span>
<span class="token comment"># 查看file2的内容</span>
$ <span class="token function">cat</span> file2
<span class="token function">test</span>
update again
</code></pre>
<p>这时，两个分支就有了各自不同的修改，分支的内容都已经不同，如何将多个分支进行合并呢？</p>
<p>可以通过下面的 <code>git merge</code> 命令来合并<code>experimental</code>到主线分支<code>master</code>：</p>
<pre><code class="prism language-bash"><span class="token comment"># 切换到master分支</span>
$ <span class="token function">git</span> checkout master
<span class="token comment"># 将experimental分支合并到master</span>
$ <span class="token function">git</span> merge -m <span class="token string">'merge experimental branch'</span> experimental
</code></pre>
<p><code>-m</code>参数仍然是需要填写合并的注释信息。</p>
<p>由于两个 branch 修改了两个不同的文件，所以合并时不会有冲突，执行上面的命令后合并就完成了。</p>
<p>如果有冲突，比如两个分支都改了一个文件 file3，则合并时会失败。首先我们在master分支上修改file3 文件并提交：</p>
<pre><code class="prism language-bash"><span class="token comment"># 切换到master分支</span>
$ <span class="token function">git</span> checkout master
<span class="token comment"># 修改file3文件</span>
$ <span class="token keyword">echo</span> <span class="token string">"master: update file3"</span> <span class="token operator">&gt;&gt;</span> file3
<span class="token comment"># 提交到master分支</span>
$ <span class="token function">git</span> commit -a -m <span class="token string">'update file3 on master'</span>
</code></pre>
<p>然后切换到 experimental，修改 file3 并提交：</p>
<pre><code class="prism language-bash"><span class="token comment"># 切换到experimental分支</span>
$ <span class="token function">git</span> checkout experimental
<span class="token comment"># 修改file3文件</span>
$ <span class="token keyword">echo</span> <span class="token string">"experimental: update file3"</span> <span class="token operator">&gt;&gt;</span> file3
<span class="token comment"># 提交到experimental分支</span>
$ <span class="token function">git</span> commit -a -m <span class="token string">'update file3 on experimental'</span>
</code></pre>
<p>切换到 master 进行合并：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> checkout master
$ <span class="token function">git</span> merge experimental
Auto-merging file3
CONFLICT （content）: Merge conflict <span class="token keyword">in</span> file3
Automatic merge failed<span class="token punctuation">;</span> fix conflicts and <span class="token keyword">then</span> commit the result.
</code></pre>
<p>合并失败后先用 git status 查看状态，会发现 file3 显示为 both modified，查看 file3内容会发现：</p>
<pre><code class="prism language-bash">$ <span class="token function">cat</span> file3
<span class="token function">test</span>
<span class="token operator">&lt;&lt;&lt;</span><span class="token operator">&lt;&lt;&lt;</span><span class="token operator">&lt;</span> HEAD
master: update file3
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>
experimental: update file3
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> experimental
</code></pre>
<p>上面的内容也可以使用 <code>git diff</code>查看，先前已经提到<code>git diff</code>不加参数可以显示未提交到缓存区中的修改内容。</p>
<p>可以看到冲突的内容都被添加到了 file3 中，我们使用 vim 编辑这个文件，去掉 Git 自动产生标志冲突的 &lt;&lt;&lt;&lt;&lt;&lt; 等符号后，根据需要只保留我们需要的内容后保存，然后使用<code>git add file3</code>和<code>git commit</code>命令来提交合并后的 file3 内容，这个过程是手动解决冲突的流程。</p>
<h2><a id="_316"></a>删除分支</h2>
<p>当我们完成合并后，不再需要experimental时，可以使用下面的命令删除：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> branch -d experimental
</code></pre>
<p><code>git branch -d</code>只能删除那些已经被当前分支的合并的分支. 如果你要强制删除某个分支的话就用<code>git branch –D</code></p>
<h2><a id="_325"></a>撤销一个合并</h2>
<p>如果你觉得你合并后的状态是一团乱麻，想把当前的修改都放弃，你可以用下面的命令回到合并之前的状态：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> reset --hard HEAD^
<span class="token comment"># 查看file3的内容，已经恢复到合并前的master上的文件内容</span>
$ <span class="token function">cat</span> file3
</code></pre>
<h2><a id="_334"></a>快速向前合并</h2>
<p>还有一种需要特殊对待的情况，在前面没有提到。通常，一个合并会产生一个合并提交（commit）， 把两个父分支里的每一行内容都合并进来。</p>
<p>但是，如果当前的分支和另一个分支没有内容上的差异，就是说当前分支的每一个提交（commit）都已经存在另一个分支里了，Git 就会执行一个 快速向前（fast forward）操作；Git 不创建任何新的提交（commit），只是将当前分支指向合并进来的分支。</p>
<h1><a id="Git__340"></a>Git 日志</h1>
<h2><a id="_341"></a>查看日志</h2>
<p>git log 命令可以显示所有的提交（commit）：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> log
</code></pre>
<p>如果提交的历史纪录很长，回车会逐步显示，输入 <code>q</code>可以退出。</p>
<p><code>git log</code> 有很多选项，可以使用 <code>git help log</code>查看，例如下面的命令就是找出所有从 “v2.5“ 开始在 fs 目录下的所有 Makefile 的修改（这个只是举例，不用操作）：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> log v2.5<span class="token punctuation">..</span> Makefile fs/
</code></pre>
<p>Git 会根据 git log 命令的参数，按时间顺序显示相关的提交（commit）。</p>
<h2><a id="_357"></a>日志统计</h2>
<p>如果用 <code>--stat</code>选项使用<code>git log</code>，它会显示在每个提交（commit）中哪些文件被修改了， 这些文件分别添加或删除了多少行内容，这个命令相当于打印详细的提交记录：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> log --stat
</code></pre>
<h2><a id="_365"></a>格式化日志</h2>
<p>你可以按你的要求来格式化日志输出。–pretty 参数可以使用若干表现格式，如 oneline：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> log --pretty<span class="token operator">=</span>oneline
</code></pre>
<p>或者你也可以使用 short 格式：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> log --pretty<span class="token operator">=</span>short
</code></pre>
<p>你也可用 <code>medium</code>，<code>full</code>，<code>fuller</code>，<code>email</code> 或<code>raw</code>。 如果这些格式不完全符合你的需求， 你也可以用 <code>--pretty=format</code>参数定义格式。</p>
<p><code>--graph</code> 选项可以可视化你的提交图（commit graph），会用ASCII字符来画出一个很漂亮的提交历史（commit history）线：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> log --graph --pretty<span class="token operator">=</span>oneline
</code></pre>
<h2><a id="_384"></a>日志排序</h2>
<p>日志记录可以按不同的顺序来显示。如果你要指定一个特定的顺序，可以为 git log 命令添加顺序参数。</p>
<p>按默认情况，提交会按逆时间顺序显示，可以指定 <code>--topo-order</code> 参数，让提交按拓扑顺序来显示（就是子提交在它们的父提交前显示）：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> log --pretty<span class="token operator">=</span>format:<span class="token string">'%h : %s'</span> --topo-order --graph
</code></pre>
<p>你也可以用 <code>--reverse</code>参数来逆向显示所有提交日志</p>
<ul>
<li>git config：配置相关信息</li>
<li>git clone：复制仓库</li>
<li>git init：初始化仓库</li>
<li>git add：添加更新内容到索引中</li>
<li>git diff：比较内容</li>
<li>git status：获取当前项目状况</li>
<li>git commit：提交</li>
<li>git branch：分支相关</li>
<li>git checkout：切换分支</li>
<li>git merge：合并分支</li>
<li>git reset：恢复版本</li>
<li>git log：查看日志</li>
</ul>
<h1><a id="_409"></a>比较内容</h1>
<h2><a id="__Git_Diff_410"></a>比较提交 - Git Diff</h2>
<p>现在我们对项目做些修改：</p>
<pre><code class="prism language-bash">$ <span class="token function">cd</span> gitproject
<span class="token comment"># 向README文件添加一行</span>
$ <span class="token keyword">echo</span> <span class="token string">"new line"</span> <span class="token operator">&gt;&gt;</span> README.md
<span class="token comment"># 添加新的文件file1</span>
$ <span class="token keyword">echo</span> <span class="token string">"new file"</span> <span class="token operator">&gt;&gt;</span> file1
</code></pre>
<p>使用 <code>git status</code>查看当前修改的状态：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> status
On branch master
Your branch is up-to-date with <span class="token string">'origin/master'</span><span class="token keyword">.</span>

Changes not staged <span class="token keyword">for</span> commit:
  （use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed）
  （use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory）

    modified:   README.md

Untracked files:
  （use <span class="token string">"git add &lt;file&gt;..."</span> to include <span class="token keyword">in</span> what will be committed）

    file1

no changes added to commit （use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span>）
</code></pre>
<p>可以看到一个文件修改了，另外一个文件添加了。如何查看修改的文件内容呢，那就需要使用 git diff 命令。git diff 命令的作用是比较修改的或提交的文件内容。</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">diff</span>
<span class="token function">diff</span> --git a/README.md b/README.md
index 21781dd<span class="token punctuation">..</span>410e719 100644
--- a/README.md
+++ b/README.md
@@ -1，2 +1，3 @@
 gitproject
 <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
+new line
</code></pre>
<p>上面的命令执行后需要使用 q 退出。命令输出当前工作目录中修改的内容，并不包含新加文件，请注意这些内容还没有添加到本地缓存区。</p>
<p>将修改内容添加到本地缓存区，通配符可以把当前目录下所有修改的新增的文件都自动添加：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> add *
</code></pre>
<p>[copy]</p>
<p>再执行<code>git diff</code>会发现没有任何内容输出，说明当前目录的修改都被添加到了缓存区，如何查看缓存区内与上次提交之间的差别呢？需要使用<code>--cached</code> 参数：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> --cached
<span class="token function">diff</span> --git a/README.md b/README.md
index 21781dd<span class="token punctuation">..</span>410e719 100644
--- a/README.md
+++ b/README.md
@@ -1，2 +1，3 @@
 gitproject
 <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
+new line
<span class="token function">diff</span> --git a/file1 b/file1
new <span class="token function">file</span> mode 100644
index 0000000<span class="token punctuation">..</span>fa49b07
--- /dev/null
+++ b/file1
@@ -0，0 +1 @@
+new <span class="token function">file</span>
</code></pre>
<p>可以看到输出中已经包含了新加文件的内容，因为 file1 已经添加到了缓存区。</p>
<p>最后我们提交代码：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> commit -m <span class="token string">'update code'</span>
</code></pre>
<p>提交后 git diff 与 git diff --cached 都不会有任何输出了。</p>
<h2><a id="_492"></a>比较分支</h2>
<p>可以用 <code>git diff</code>来比较项目中任意两个分支的差异。</p>
<p>我们首先创建一个新的分支<code>test</code>，并在该分支上提交一些修改：</p>
<pre><code class="prism language-bash"><span class="token comment"># 创建test分支并切换到该分支</span>
$ <span class="token function">git</span> branch <span class="token function">test</span>
$ <span class="token function">git</span> checkout <span class="token function">test</span>
<span class="token comment"># 添加新的一行到file1</span>
$ <span class="token keyword">echo</span> <span class="token string">"branch test"</span> <span class="token operator">&gt;&gt;</span> file1
<span class="token comment"># 创建新的文件file2</span>
$ <span class="token keyword">echo</span> <span class="token string">"new file2"</span> <span class="token operator">&gt;&gt;</span> file2
<span class="token comment"># 提交所有修改</span>
$ <span class="token function">git</span> add *
$ <span class="token function">git</span> commit -m <span class="token string">'update test branch'</span>
</code></pre>
<p>然后，我们查看 test 分支和 master 之间的差别：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> master <span class="token function">test</span>
<span class="token function">diff</span> --git a/file1 b/file1
index fa49b07<span class="token punctuation">..</span>17059cd 100644
--- a/file1
+++ b/file1
@@ -1 +1，2 @@
 new <span class="token function">file</span>
+branch <span class="token function">test</span>
<span class="token function">diff</span> --git a/file2 b/file2
new <span class="token function">file</span> mode 100644
index 0000000<span class="token punctuation">..</span>80e7991
--- /dev/null
+++ b/file2
@@ -0，0 +1 @@
+new file2
</code></pre>
<p><code>git diff</code> 是一个难以置信的有用的工具，可以找出你项目上任意两个提交点间的差异。可以使用 <code>git help diff</code>详细查看其他参数和功能。</p>
<h2><a id="_530"></a>更多的比较选项</h2>
<pre><code class="prism language-bash"><span class="token comment"># 切换到master</span>
$ <span class="token function">git</span> checkout master

<span class="token comment"># 查看与test分支的区别</span>
$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token function">test</span>
<span class="token function">diff</span> --git a/file1 b/file1
index 17059cd<span class="token punctuation">..</span>fa49b07 100644
--- a/file1
+++ b/file1
@@ -1，2 +1 @@
 new <span class="token function">file</span>
-branch <span class="token function">test</span>
<span class="token function">diff</span> --git a/file2 b/file2
deleted <span class="token function">file</span> mode 100644
index 80e7991<span class="token punctuation">..</span>0000000
--- a/file2
+++ /dev/null
@@ -1 +0，0 @@
-new file2
</code></pre>
<p>你也以加上路径限定符，来只比较某一个文件或目录：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token function">test</span> file1
<span class="token function">diff</span> --git a/file1 b/file1
index 17059cd<span class="token punctuation">..</span>fa49b07 100644
--- a/file1
+++ b/file1
@@ -1，2 +1 @@
 new <span class="token function">file</span>
-branch <span class="token function">test</span>
</code></pre>
<p>上面这条命令会显示你当前工作目录下的<code>file1</code>与 <code>test</code> 分支之间的差别。</p>
<p><code>--stat</code>参数可以统计一下有哪些文件被改动，有多少行被改动：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token function">test</span> --stat
 file1 <span class="token operator">|</span> 1 -
 file2 <span class="token operator">|</span> 1 -
 2 files changed， 2 deletions（-）
</code></pre>
<h1><a id="_575"></a>分布式的工作流程</h1>
<h2><a id="_577"></a>分布式的工作流程</h2>
<p>你目前的项目在<code>/home/shiyanlou/gitproject</code> 目录下，这是我们的 Git 仓库（repository），另一个用户也想与你协作开发。他的工作目录在这台机器上，如何让他提交代码到你的 Git 仓库呢？</p>
<p>首先，我们假设另一个用户也用 shiyanlou 用户登录，只是工作在不同的目录下开发代码，实际工作中不太可能发生，大部分情况都是多个用户，这个假设只是为了让实验简化。</p>
<p>该用户需要从 Git 仓库进行克隆：</p>
<pre><code class="prism language-bash"><span class="token comment"># 进入到临时目录</span>
$ <span class="token function">cd</span> /tmp
<span class="token comment"># 克隆git仓库</span>
$ <span class="token function">git</span> clone /home/shiyanlou/gitproject myrepo
$ <span class="token function">ls</span> -l myrepo
-rw-rw-r-- 1 shiyanlou shiyanlou 31 Dec 22 08:24 README.md
-rw-rw-r-- 1 shiyanlou shiyanlou  9 Dec 22 08:24 file1
</code></pre>
<p>这就建了一个新的 “myrepo” 的目录，这个目录里包含了一份gitproject仓库的克隆。这份克隆和原始的项目一模一样，并且拥有原始项目的历史记录。</p>
<p>在 myrepo 做了一些修改并且提交:</p>
<pre><code class="prism language-bash">$ <span class="token function">cd</span> /tmp/myrepo

<span class="token comment"># 添加新的文件newfile</span>
$ <span class="token keyword">echo</span> <span class="token string">"newcontent"</span> <span class="token operator">&gt;</span> newfile

<span class="token comment"># 提交修改</span>
$ <span class="token function">git</span> add newfile
$ <span class="token function">git</span> commit -m <span class="token string">"add newfile"</span>
</code></pre>
<p>myrepo 修改完成后，如果我们想合并这份修改到 <code>gitproject</code>的 git 仓库该如何做呢？</p>
<p>可以在仓库<code>/home/shiyanlou/gitproject</code> 中把<code>myrepo</code>的修改给拉 （pull）下来。执行下面几条命令:</p>
<pre><code class="prism language-bash">$ <span class="token function">cd</span> /home/shiyanlou/gitproject
$ <span class="token function">git</span> pull /tmp/myrepo master
remote: Counting objects: 5， done.
remote: Compressing objects: 100% （2/2）， done.
remote: Total 3 （delta 0）， reused 0 （delta 0）
Unpacking objects: 100% （3/3）， done.
From /tmp/myrepo
 * branch            master     -<span class="token operator">&gt;</span> FETCH_HEAD
Updating 8bb57aa<span class="token punctuation">..</span>866c452
Fast-forward
 newfile <span class="token operator">|</span> 1 +
 1 <span class="token function">file</span> changed， 1 insertion（+）
 create mode 100644 newfile

<span class="token comment"># 查看当前目录文件</span>
$ <span class="token function">ls</span>                                                                                         
README.md  file1  newfile
</code></pre>
<p>这就把 <code>myrepo</code>的主分支合并到了<code>gitproject</code> 的当前分支里了。</p>
<p>如果 <code>gitproject</code>在<code>myrepo</code> 修改文件内容的同时也做了修改的话，可能需要手工去修复冲突。</p>
<p>如果你要经常操作远程分支（remote branch），你可以定义它们的缩写:</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> remote add myrepo /tmp/myrepo
</code></pre>
<p><code>git pull</code> 命令等同于执行两个操作: 先使用 <code>git fetch</code> 从远程分支抓取最新的分支修改信息，然后使用 <code>git merge</code>把修改合并进当前的分支。</p>
<p><code>gitproject</code> 里可以用 <code>git fetch</code> 来执行<code>git pull</code> 前半部分的工作， 但是这条命令并不会把抓下来的修改合并到当前分支里：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> fetch myrepo
From /tmp/myrepo
 * <span class="token punctuation">[</span>new branch<span class="token punctuation">]</span>      master     -<span class="token operator">&gt;</span> myrepo/master
</code></pre>
<p>获取后，我们可以通过 <code>git log</code> 查看远程分支做的所有修改，由于我们已经合并了所有修改，所以不会有任何输出：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> log -p master<span class="token punctuation">..</span>myrepo/master
</code></pre>
<p>当检查完修改后，<code>gitproject</code>可以把修改合并到它的主分支中：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> merge myrepo/master
Already up-to-date.
</code></pre>
<p>如果我们在 <code>myrepo</code> 目录下执行 <code>git pull</code>会发生什么呢？</p>
<p><code>myrepo</code>会从克隆的位置拉取代码并更新本地仓库，就是把 <code>gitproject</code>上的修改同步到本地:</p>
<pre><code class="prism language-bash"><span class="token comment"># 进入到gitproject</span>
$ <span class="token function">cd</span> /home/shiyanlou/gitproject

<span class="token comment"># 添加一行内容到newfile</span>
$ <span class="token keyword">echo</span> <span class="token string">"gitproject: new line"</span> <span class="token operator">&gt;&gt;</span> newfile

<span class="token comment"># 提交修改</span>
$ <span class="token function">git</span> commit -a -m <span class="token string">'add newline to newfile'</span>
<span class="token punctuation">[</span>master 8c31532<span class="token punctuation">]</span> add newline to newfile
 1 <span class="token function">file</span> changed， 1 insertion（+）

<span class="token comment"># 进入myrepo目录</span>
$ <span class="token function">cd</span> /tmp/myrepo

<span class="token comment"># 同步gitproject的所有修改</span>
$ <span class="token function">git</span> pull
remote: Counting objects: 6， done.
remote: Compressing objects: 100% （2/2）， done.
remote: Total 3 （delta 1）， reused 0 （delta 0）
Unpacking objects: 100% （3/3）， done.
From /home/shiyanlou/gitproject
   8bb57aa<span class="token punctuation">..</span>8c31532  master     -<span class="token operator">&gt;</span> origin/master
Updating 866c452<span class="token punctuation">..</span>8c31532
Fast-forward
 newfile <span class="token operator">|</span> 1 +
 1 <span class="token function">file</span> changed， 1 insertion（+）
</code></pre>
<p>因为 <code>myrepo</code> 是从<code>gitproject</code>仓库克隆的，那么他就不需要指定<code>gitproject</code>仓库的地 址。因为 Git 把<code>gitproject</code> 仓库的地址存储到 myrepo 的配置文件中，这个地址就是在<code>git pull</code> 时默认使用的远程仓库：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> config --get remote.origin.url
/home/shiyanlou/gitproject
</code></pre>
<p>如果<code>myrepo</code> 和<code>gitproject</code>在不同的主机上，可以通过<code>ssh</code>协议来执行<code>clone</code> 和<code>pull</code>操作：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> clone localhost:/home/shiyanlou/gitproject <span class="token function">test</span>
</code></pre>
<p>这个命令会提示你输入 shiyanlou 用户的密码，用户密码随机，可以点击实验操作界面右侧工具栏的 SSH直连 按钮查看。</p>
<h2><a id="_Git__704"></a>公共 Git 仓库</h2>
<p>开发过程中，通常大家都会使用一个公共的仓库，并 clone 到自己的开发环境中，完成一个阶段的代码后可以告诉目标仓库的维护者来<code>pull</code>自己的代码。</p>
<p>如果你和维护者都在同一台机器上有帐号，那么你们可以互相从对 方的仓库目录里直接拉所作的修改，git 命令里的仓库地址也可以是本地的某个目录名：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> clone 仓库A的路径
$ <span class="token function">git</span> pull 仓库B的路径
</code></pre>
<p>也可以是一个ssh地址：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> clone ssh://服务器/账号/仓库名称
</code></pre>
<h2><a id="_718"></a>将修改推到一个公共仓库</h2>
<p>通过 http 或是 git 协议，其它维护者可以通过远程访问的方式抓取（fetch）你最近的修改，但是他们没有写权限。如何将本地私有仓库的最近修改主动上传到公共仓库中呢？</p>
<p>最简单的办法就是用 git push 命令，推送本地的修改到远程 Git 仓库，执行下面的命令:</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> push ssh://服务器仓库地址 master:master
</code></pre>
<p>或者</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> push ssh://服务器仓库地址 master
</code></pre>
<p><code>git push</code>命令的目地仓库可以是<code>ssh</code>或 <code>http/https</code>协议访问</p>
<h2><a id="_734"></a>当推送代码失败时要怎么办</h2>
<p>如果推送（push）结果不是快速向前 fast forward，可能会报像下面一样的错误：</p>
<pre><code class="prism language-bash">error: remote <span class="token string">'refs/heads/master'</span> is not an ancestor of
local  <span class="token string">'refs/heads/master'</span><span class="token keyword">.</span>
Maybe you are not up-to-date and need to pull first?
error: failed to push to <span class="token string">'ssh://yourserver.com/~you/proj.git'</span>
</code></pre>
<p>这种情况通常是因为没有使用<code>git pull</code>获取远端仓库的最新更新，在本地修改的同时，远端仓库已经变化了（其他协作者提交了代码），此时应该先使用<code>git pull</code>合并最新的修改后再执行 <code>git push</code>：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> pull
$ <span class="token function">git</span> push ssh://服务器仓库地址 master
</code></pre>
<h1><a id="Git_751"></a>Git标签</h1>
<h2><a id="_752"></a>轻量级标签</h2>
<p>我们可以用 git tag 不带任何参数创建一个标签（tag）指定某个提交（commit）:</p>
<pre><code class="prism language-bash"><span class="token comment"># 进入到gitproject目录</span>
$ <span class="token function">cd</span> /home/shiyanlou/gitproject

<span class="token comment"># 查看git提交记录</span>


$ <span class="token function">git</span> log

<span class="token comment"># 选择其中一个记录标志位stable-1的标签，注意需要将后面的8c315325替换成仓库下的真实提交内，commit的名称很长，通常我们只需要写前面8位即可</span>
$ <span class="token function">git</span> tag stable-1 8c315325

<span class="token comment"># 查看当前所有tag</span>
$ <span class="token function">git</span> tag
stable-1
</code></pre>
<p>这样，我们可以用stable-1 作为提交 8c315325 的代称。</p>
<p>前面这样创建的是一个“轻量级标签”。</p>
<p>如果你想为一个tag添加注释，或是为它添加一个签名， 那么我们就需要创建一个 “标签对象”。<br>
标签对象</p>
<p><code>git tag</code>中使用<code>-a</code>，<code>-s</code>或是 <code>-u</code>三个参数中任意一个，都会创建一个标签对象，并且需要一个标签消息（tag message）来为 tag 添加注释。 如果没有 <code>-m</code>或是 <code>-F</code>这些参数，命令执行时会启动一个编辑器来让用户输入标签消息。</p>
<p>当这样的一条命令执行后，一个新的对象被添加到 Git 对象库中，并且标签引用就指向了一个标签对象，而不是指向一个提交，这就是与轻量级标签的区别。</p>
<p>下面是一个创建标签对象的例子:</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> tag -a stable-2 8c315325 -m <span class="token string">"stable 2"</span>
$ <span class="token function">git</span> tag
stable-1
stable-2
</code></pre>
<h2><a id="_790"></a>签名的标签</h2>
<p>签名标签可以让提交和标签更加完整可信。如果你配有GPG key，那么你就很容易创建签名的标签。首先你要在你的<code>.git/config</code> 或 <code>~/.gitconfig</code>里配好key。</p>
<p>下面是示例:</p>
<pre><code class="prism language-bash"><span class="token punctuation">[</span>user<span class="token punctuation">]</span>
    signingkey <span class="token operator">=</span> <span class="token operator">&lt;</span>gpg-key-id<span class="token operator">&gt;</span>
</code></pre>
<p>你也可以用命令行来配置:</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> config （--global） user.signingkey <span class="token operator">&lt;</span>gpg-key-id<span class="token operator">&gt;</span>
</code></pre>
<p>现在你可以在创建标签的时候使用 -s 参数来创建“签名的标签”：</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> tag -s stable-1 1b2e1d63ff
</code></pre>
<p>如果没有在配置文件中配 GPG key，你可以用 -u 参数直接指定。</p>
<pre><code class="prism language-bash">$ <span class="token function">git</span> tag -u <span class="token operator">&lt;</span>gpg-key-id<span class="token operator">&gt;</span> stable-1 1b2e1d63ff
</code></pre>
</div>
</body>

</html>
